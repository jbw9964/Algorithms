
### [Source code](./예상 대진표.py)

---

### 풀이 방법

- 이전에 [`[148652, 유사 칸토어 비트열]`](../148652. 유사 칸토어 비트열/) 문제를 트리 구조를 이용해 풀었었다.
- 해당 문제를 풀며 `l_leaf` 와 `r_leaf` 가 만나는 `height` 를 계산했었는데, 이를 동일하게 적용하면 될 것 같아 이를 활용했다.

---

### 풀이 중 마주친 issue

- 없음.

---

### issue 해결 과정

- 없음.

---

### 추후 개선 사항

- 아래 코드는 숏 코딩이지만 충분히 배울점이 많다.

```python
def solution(n, a, b):
    return ((a - 1)^(b - 1)).bit_length()
```

- 내가 작성한 코드는 다음과 같다.

```python
def solution(n, a, b):
    a, b = a - 1, b - 1

    answer = 0
    while a != b : 
        a //= 2
        b //= 2
        answer += 1

    return answer
```

- 둘의 생각하는 방식은 동일하지만 숏 코딩 방식이 훨신 빠르다. 애초에 2 로 계속 나눠주면 되는데, 숏코딩은 비트 연산자를 이용해 구현하였다.
- 해당 문제에서 비트 연산자를 사용할 생각을 못했었는데, 이를 활용하게 된다면 훨씬 빠르게 연산이 끝난다.
